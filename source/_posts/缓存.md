---
title: 浏览器缓存
date: 2018-08-29 16:02:10
tags:
---
# 浏览器缓存
浏览器缓存分为两种，分别为 **强缓存**（也称本地缓存） 和 **协商缓存**（也称弱缓存）。

对于强缓存和协商缓存，判定过程如下：

浏览器加载资源时，先根据 response 的 header 中某些字段判断是否命中强缓存，若命中，浏览器直接从缓存中读取资源，不会发送请求到服务器。
当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，此时服务器根据 resquest 的 header 中某些字段判断是否命中协商缓存，若命中，服务器返回请求，但不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源。
对于强缓存和协商缓存，共同点在于，若命中，它们都是从客户端缓存中加载资源，而不是从服务器加载资源数据；而不同点在于，强缓存不发请求到服务器，协商缓存会发请求到服务器以咨询缓存是否过期。

<!-- more -->
##### 强缓存
强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。
强缓存中，普通刷新会忽略它，但不会清除它；而强制刷新，请求会带上 Cache-Control:no-cache 和 Pragma:no-cache。
##### 协商缓存
简而言之，协商缓存就是想服务器发送请求以咨询本地缓存是否可用。
协商缓存主要涉及两组 header 字段： Etag 和 If-None-Match、Last-Modified 和 If-Modified-Since.

普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个 js 文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。
相关请求头下文有详细介绍


### iframe

iframe算是个历史问题,比较早期的网站使用 iframe，主要是用于导航栏（navigator）。因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的 URL 不会随着页面的变化而变化。
[参考](https://www.zhihu.com/question/20653055/answer/15751248)


![image](http://pbyegcye6.bkt.clouddn.com/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%8D%B4%E4%BB%8E%E7%A1%AC%E7%9B%98%E8%AF%BB%E7%BC%93%E5%AD%98.png)

这个iframe里内嵌的一个页面,==采用的协商缓存的策略,可是却直接从硬盘(disk)里面获取缓存,并没有与服务器校对,直接返回200而不是304==.这样会造成服务器上的文件已经被修改过了,但是浏览器显示的文件却不是最新的.对于这样的情况,下文提供了一些解决办法希望给遇到同样问题的人提供参考.




# 缓存相关请求头

#### Expires

Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。
所以HTTP 1.1 的版本，使用Cache-Control替代。

#### Cache-Control
* private:         客户端可以缓存
* public:              客户端和代理服务器都可缓存
* max-age=xxx:   缓存的内容将在 xxx 秒后失效
* no-cache:          需要使用对比缓存来验证缓存数据
* no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发

#### last-modified 和 If-Modify-Since
服务器在响应请求时，告诉浏览器资源的最后修改时间。
其执行过程如下：

 1.当第一次发起 HTTP 请求时，服务器 response 的 header 中包含 Last-Modify ，标明该资源的最后修改时间，如：`Mon, 16 Jul 2018 11:14:47 GMT`

2.当再次发起 HTTP 请求时，客户端 requset 的 header 中包含 If-Modify-Since 字段，该值为缓存之前服务器返回的 Last-Modify 的值，服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。

3.如果命中缓存，则返回 304 ，并且不会返回资源内容，并且不会返回 Last-Modify 

### Etag
服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
既然有了last-modified 和 If-Modify-Since来让浏览器知道本地的缓存副本是否足够新那为什么需要Etag呢?
那是因为Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间.

此外,Etag是可以跟Last-Modified一起使用的,服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。


### If-None-Match
再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。



# 页面缓存的一些解决方法
## 比较简单解决方法
在html文件加入mate标签 控制请求头 对chrome浏览器无效
```
<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT= "no-cache, must-revalidate"> 
<META HTTP-EQUIV="expires" CONTENT= "Wed, 26 Feb 1997 08:21:57 GMT"> 
```

## 另一解决方法(未实践)
根据协强缓存策略:强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的，用来表示资源的缓存时间
只需要在nginx反向代理的时候加``Cache-Control:no-cache``和``Pragma:no-cache`` 这两个请求头就能清除缓存,通过合理设置``expires``缓存时间就能很好的合理运用缓存 
[修改方法](http://www.nginx.cn/doc/standard/httpheaders.html)

## 目前使用解决办法



### 原理
浏览器为了提高用户访问同一页面的速度，会对页面数据进行缓存。当url请求地址不变时，有时候会导致浏览器不发送请求，直接从缓存中读取之前的数据。如果数据改变了，而没加随机数，读取的数据会跟之前一样。加上随机数，就是欺骗浏览器url改变了，会每次都向服务器发送请求而不去读缓存。

除了随机数以外还能在在ULR后面加上者**版本号** 和 **文件的md5** 
用md5的话每次修改后都会改变 保证每次都能获取修改后的资源,包括CDN 随机数每次都变化浪费请求的资源 版本号在两者之间CDN更新会不同步

### 总结
百度一搜"版本防缓存"基本都是加版本号和md5的,加随机数的比较少.其实缓存是必须的,如果每次都要从服务器获取资源的话,会影响用户的体验.一是HTTP 1.0 和1.1的最大并发连接数是6左右 (不同浏览器有差异),二是建立连接到获取数据需要时间.要运用好缓存,而不是一味的强制缓存或者禁止缓存.这样才能收益最大化.


#### 通过插件添加md5码来防止缓存

*下面讲的跟浏览器无关,只是用工具批量加?v=(md5)来解决ifame强制缓存的问题,有需要的朋友可以参考*

grunt和gulp都是基于task的前端构建工具这里我用的是 **gulp**
因为要改的项目历史比较久远,本身并没有什么自动化的工具,也不敢改动太多所以机缘巧合下选了这个工具.

引用下面3个文件
```
var rev = require('gulp-rev');
var revFormat = require('gulp-rev-Format');
var revReplace = require('gulp-rev-replace');
var replace = require('gulp-replace');

```
前面3个是提取文件对应md5码并且格式化
最后一个是替换到对应URL后面

被提取出来的文件对应的md5会被保存在`` ./app/rev-manifest.json``文件里,内容类如下:
```
{
  "Activity_CheckInfo2.html": "Activity_CheckInfo2.259348dacd.cache.html",
  "Activity_Definition.html": "Activity_Definition.22d05704c3.cache.html",
  .......
}
```
本来插件的功能是将文件名由 ``A.html``改为 ``A.(md5).html``,这显然与我现在在URL后加``?t=(md5)``的实践不符,所以我对``task``进行加工加上``.cache``来识别md5到哪结束

```
gulp.task('rev', () => {
  gulp.src(['pc_member/**/*.js', 'pc_member/**/*.css', 'pc_member/views/*.html', 'pc_member/views/info/*.html', 'pc_member/views/logs/*.html', 'pc_member/views/statistics/*.html', 'pc_member/views/system/*.html', 'pc_member/views/activity/*.html'])
    .pipe(rev())
    .pipe(revFormat({
      prefix: '.', // 在版本号前增加字符  
      suffix: '.cache', // 在版本号后增加字符  
      lastExt: false
    }))
    .pipe(rev.manifest({
      merge: true // merge with the existing manifest (if one exists)
    }))
    .pipe(gulp.dest("app/"));
});
```
整理出要用的结构以后就可以提取出来替换进html里面了
上面提到加``.cache``是为了正则运行更方便的提取中间那段md5
提取出来后通过``gulp-revReplace``插件替换到html文件里面就好了
详细的讲解在第二篇参考文章里面有详细描叙 我这里去掉了部分我不需要的组件更为精简.
想详细了解的可以前去浏览
```
gulp.task('add-version', ['rev'], function () {
  var manifest = gulp.src(["./app/rev-manifest.json"]);

  function modifyUnreved(filename) {
    return filename;
  }

  function modifyReved(filename) {
    // filename是：admin.69cef10fff.cache.css的一个文件名  
    // 在这里才发现刚才用gulp-rev-format的作用了吧？就是为了做正则匹配，  
    if (filename.indexOf('.cache') > -1) {
      // 通过正则和relace得到版本号：69cef10fff  
      const _version = filename.match(/\.[\w]*\.cache/)[0].replace(/(\.|cache)*/g, "");
      // 把版本号和gulp-rev-format生成的字符去掉，剩下的就是原文件名：admin.css  
      const _filename = filename.replace(/\.[\w]*\.cache/, "");
      // 重新定义文件名和版本号：admin.css?v=69cef10fff  
      filename = _filename + "?v=" + _version;
      // 返回由gulp-rev-replace替换文件名  
      return filename;
    }
    return filename;
  }
  gulp.src(['pc_member/**/*.html'])
  // 删除原来的版本   
    .pipe(replace(/(\.[a-z]+)\?(v=)[^\'\"\&]*/g, "$1"))
    .pipe(replace(/(\.[a-z]+)\?[^\'\"\&]*/g, function (match) {
      var res = match.replace('?', '&');
      return res;
    }))
    .pipe(revReplace({
      manifest: manifest,
      modifyUnreved: modifyUnreved,
      modifyReved: modifyReved
    }))
    .pipe(gulp.dest('dist/'))
    .pipe(connect.reload());
});
```
参考网址:

[浅析HTTP缓存的机制-浏览器缓存 | OBKoro1's Blog](http://obkoro1.com/2018/06/09/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/)

[HTTP 缓存机制（强缓存与协商缓存） | BangZ's 梦工厂](https://hexo.bangz.me/archives/http-cache-tutorial.html)

[http协商缓存VS强缓存 - wonyun - 博客园](https://www.cnblogs.com/wonyun/p/5524617.html)

[前端静态资源版本更新与缓存之——通过gulp 在原html文件上自动化添加js、css版本号 - CSDN博客](https://blog.csdn.net/zchcode/article/details/52421871)

[gulp进阶：文件号自动添加MD5后缀的三种方法与坑位提醒 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000010315249)